// ********RoostGPT********
/*
Test generated by RoostGPT for test dm-java-test-29 using AI Type Azure Open AI and AI Model roost-gpt4-32k

1. **Scenario:** Test if JwtConfig instance is not null when jwtConfig function is called.
     - **Expected Result:** The JwtConfig instance should not be null.

2. **Scenario:** Test whether the jwtConfig() function is executed without any exceptions during its execution.
     - **Expected Result:** The method should run without throwing any exceptions.

3. **Scenario:** Test whether the jwtConfig() function returns a JwtConfig object of the correct type.
     - **Expected Result:** The return type of the method should be JwtConfig.

4. **Scenario:** Test whether the jwtConfig() function returns a new JwtConfig instance for each call.
     - **Expected Result:** Each call to jwtConfig() should return a brand new JwtConfig instance.

5. **Scenario:** Test if the properties of the JwtConfig object are initialized correctly when jwtConfig() function is called.
     - **Expected Result:** All properties of the JwtConfig instance should be initialized correctly.

6. **Scenario:** Test for thread safety. Check if jwtConfig() function returns correct results when called concurrently from multiple threads.
     - **Expected Result:** The function should work correctly and return the correct JwtConfig instances even when called concurrently from multiple threads.

7. **Scenario:** Test for performance. Check how fast the jwtConfig() function can create and return new JwtConfig instances.
     - **Expected Result:** The function should be able to create and return new JwtConfig instance within the acceptable time frame as per the performance requirement.

8. **Scenario:** Test the jwtConfig() function in different environments (development, testing, production).
     - **Expected Result:** The function should work correctly in all environments and always return a correct JwtConfig instance.

Note: Every test scenario is dependent on the actual implementation of the JwtConfig class. Adjustments might be needed depending on the class structure and functionality.
*/

// ********RoostGPT********
package com.wishop.customer.security;

import javax.servlet.http.HttpServletResponse;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.http.HttpMethod;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import com.wishop.common.configurations.JwtConfig;

@EnableGlobalMethodSecurity(prePostEnabled = true)
@EnableWebSecurity
public class SecurityCredentialsConfig extends WebSecurityConfigurerAdapter {

    private UserDetailsService userDetailsService;
    private JwtConfig jwtConfig;

    @Autowired
    public SecurityCredentialsConfig(UserDetailsService userDetailsService, JwtConfig jwtConfig) {
        this.userDetailsService = userDetailsService;
        this.jwtConfig = jwtConfig;
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.csrf().disable()
            .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS).and()
            .addFilterAfter(new JwtTokenAuthenticationFilter(jwtConfig), UsernamePasswordAuthenticationFilter.class)
            .authorizeRequests()
            .antMatchers("/ping**").permitAll()
            .antMatchers("/actuator/**").permitAll()
            .antMatchers(HttpMethod.POST, jwtConfig.getUri()).permitAll()
            .and().exceptionHandling().authenticationEntryPoint((req, rsp, e) -> rsp.sendError(HttpServletResponse.SC_UNAUTHORIZED));
    }

    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.userDetailsService(userDetailsService).passwordEncoder(passwordEncoder());
    }

    @Bean
    public JwtConfig jwtConfig() {
        return new JwtConfig();
    }

    @Bean
    public BCryptPasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
